Allocation
Goals:
    come as close to guaranteed allocation as possible.
    respect user prefs
    maximize througput

We can estimate the total throughput of the system,
   and we can break it down by resource type,
   and for a given set of keywords we can see how much is not vetoed.

Goal: someone comes to use the an allocation request, which includes
- the available app version types
    (CPU, NVIDIA, AMD, platform, VM)
- the set of keywords
- # FLOPs

Parameters:
- what % of resources to use for allocations (50?)
- max % for a single allocation (10?)

Projects also get an unallocated share,
with a fraction determined by the popularity of their keywords
(and keywords of their apps)

to process an allocation request:
select hosts that aren't ruled out by keywords
total their flops for eligible resources
------------
Allocation is at the granularity of project.
If you have apps that need separate prioritization,
make them separate projects.
Projects are cheap.

An "allocation" consists of
- an initial balance
- the rate of balance accrual
- the interval of balance accrual
where "balance" is in terms of FLOPs

SU serves as a meta-scheduler.

It keeps track of targets, allocations, balances, host assignments.

There are two measures of work done:
1) REC, as reported directly by clients
2) credit, as reported by projects

2) is cheap-resistant, 1) is not
1) is up-to-date, 2) is not (long jobs, validation delay)

Approach:
use 1) from SU scheduling, but don't show it to volunteers
(eliminate incentive for cheating)

show 2) to volunteers.

?? what if SU assigns a host to a project, and the project doesn't have work?
	SU should work in a reasonable way for sporadic workloads
Need way for SU to check if project has work?

-----------
client changes:
	report CPU/GPU time per app and project
